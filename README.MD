# Projeto CRUD API

![Java](https://img.shields.io/badge/Java-21-blue?style=for-the-badge&logo=openjdk)
![Spring Boot](https://img.shields.io/badge/Spring%20Boot-2.5.4-brightgreen?style=for-the-badge&logo=spring)
![PostgreSQL](https://img.shields.io/badge/PostgreSQL-13-orange?style=for-the-badge&logo=postgresql)
![Maven](https://img.shields.io/badge/Maven-3.8.1-yellow?style=for-the-badge)
![License](https://img.shields.io/badge/License-MIT-green?style=for-the-badge)


# ğŸš€ Objetivo

O objetivo desse projeto Ã© desenvolver um CRUD (Create, Update, Read, Delete) por meio da API projetada

# ğŸ–¥ï¸ PreparaÃ§Ã£o do ambiente e tecnologias aplicadas

## Requisitos necessÃ¡rios:
- JDK 21
- Maven
- Postman ou Insomnia (para fazer requisiÃ§Ãµes HTTP)
- PgAdmin (PostgreSQL)
- IDE (IntelliJ, STS, Eclipse, VSCode, etc)

## Como serÃ¡ desenvolvido
- Uso do Spring Initalizr para criar o repositÃ³rio do projeto
- PostgreSQL
- Flyway e conceito de Migrations

## Spring Initializr
VÃ¡ no [Spring Initializr](https://start.spring.io/) e siga as seguintes instruÃ§Ãµes:
- Adicione as dependÃªncias:
    - Spring Web;
    - Spring Data JPA;
    - Flyway Migration;
    - PostgreSQL Driver;
- Selecione a linguagem Java;
- Packaging sendo `jar`;
- Selecione a versÃ£o do seu JDK;

<img src="./images/initializr.png" width=70%>

# Camadas de um projeto Spring

## ğŸ—ï¸ Arquitetura do Projeto

Este projeto segue o padrÃ£o de **arquitetura em camadas** utilizando o Spring Boot, conforme ilustrado abaixo:

<img src="./images/layersSpring.png" width=70%>

### 1. Controller (Camada de ApresentaÃ§Ã£o)
- Recebe requisiÃ§Ãµes HTTP e envia respostas.
- Converte dados de entrada (JSON, XML, etc.) para objetos Java.
- Encaminha as requisiÃ§Ãµes para a camada **Service**.
- **AnotaÃ§Ã£o principal:** `@RestController` ou `@Controller`.

### 2. Service (Camada de NegÃ³cio)
- ContÃ©m as regras de negÃ³cio da aplicaÃ§Ã£o.
- Faz a ponte entre o **Controller** e o **Repository**.
- Aplica validaÃ§Ãµes, cÃ¡lculos e orquestra chamadas de mÃ©todos.
- **AnotaÃ§Ã£o principal:** `@Service`.

### 3. Repository (Camada de Acesso a Dados)
- ResponsÃ¡vel pela interaÃ§Ã£o com o banco de dados.
- Executa operaÃ§Ãµes de CRUD.
- Utiliza JPA/Hibernate ou SQL nativo.
- **AnotaÃ§Ã£o principal:** `@Repository` (no Spring Data, pode ser implÃ­cita).

### 4. Model (Camada de Modelo)
- Representa os dados da aplicaÃ§Ã£o.
- Inclui:
  - **Entities**: Classes anotadas com `@Entity` que mapeiam tabelas do banco.
  - **DTOs**: Objetos para transferÃªncia de dados entre camadas.
- Usada por todas as camadas para representar informaÃ§Ãµes.

---

### **Fluxo de execuÃ§Ã£o**:
1. O cliente envia uma requisiÃ§Ã£o â†’ **Controller**
2. O Controller chama o **Service**
3. O Service consulta o **Repository**
4. O Repository interage com o **Model** e o banco
5. A resposta sobe de volta ao cliente

<br>

# ğŸ‘¨â€ğŸ’» SHOW ME THE CODE!!!

## Estrutura do projeto
```
C:.
â””â”€â”€â”€crud
    â”‚   .gitattributes
    â”‚   .gitignore
    â”‚   HELP.md
    â”‚   mvnw
    â”‚   mvnw.cmd
    â”‚   pom.xml
    â”‚   README.MD
    â”‚
    â”œâ”€â”€â”€.mvn
    â”‚   â””â”€â”€â”€wrapper
    â”‚           maven-wrapper.properties
    â”‚
    â”œâ”€â”€â”€.vscode
    â”‚       settings.json
    â”‚
    â”œâ”€â”€â”€images
    â”‚       initializr.png
    â”‚       layersSpring.png
    â”‚
    â”œâ”€â”€â”€src
    â”‚   â”œâ”€â”€â”€main
    â”‚   â”‚   â”œâ”€â”€â”€java
    â”‚   â”‚   â”‚   â””â”€â”€â”€com
    â”‚   â”‚   â”‚       â””â”€â”€â”€pedro
    â”‚   â”‚   â”‚           â””â”€â”€â”€crud
    â”‚   â”‚   â”‚               â”‚   CrudApplication.java
    â”‚   â”‚   â”‚               â”‚
    â”‚   â”‚   â”‚               â”œâ”€â”€â”€controller
    â”‚   â”‚   â”‚               â”‚       ProductController.java
    â”‚   â”‚   â”‚               â”‚
    â”‚   â”‚   â”‚               â”œâ”€â”€â”€dtos
    â”‚   â”‚   â”‚               â”‚       ProductDto.java
    â”‚   â”‚   â”‚               â”‚
    â”‚   â”‚   â”‚               â”œâ”€â”€â”€model
    â”‚   â”‚   â”‚               â”‚       Product.java
    â”‚   â”‚   â”‚               â”‚
    â”‚   â”‚   â”‚               â””â”€â”€â”€repository
    â”‚   â”‚   â”‚                       ProductRepository.java
    â”‚   â”‚   â”‚
    â”‚   â”‚   â””â”€â”€â”€resources
    â”‚   â”‚       â”‚   application.properties
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€â”€db
    â”‚   â”‚       â”‚   â””â”€â”€â”€migration
    â”‚   â”‚       â”‚           V1__create-table-product.sql
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€â”€static
    â”‚   â”‚       â””â”€â”€â”€templates
    â”‚   â””â”€â”€â”€test
    â”‚       â””â”€â”€â”€java
    â”‚           â””â”€â”€â”€com
    â”‚               â””â”€â”€â”€pedro
    â”‚                   â””â”€â”€â”€crud
    â”‚                           CrudApplicationTests.java
    â”‚
    â””â”€â”€â”€target
        â”œâ”€â”€â”€classes
        â”‚   â”‚   application.properties
        â”‚   â”‚
        â”‚   â”œâ”€â”€â”€com
        â”‚   â”‚   â””â”€â”€â”€pedro
        â”‚   â”‚       â””â”€â”€â”€crud
        â”‚   â”‚           â”‚   CrudApplication.class
        â”‚   â”‚           â”‚
        â”‚   â”‚           â”œâ”€â”€â”€controller
        â”‚   â”‚           â”‚       ProductController.class
        â”‚   â”‚           â”‚
        â”‚   â”‚           â”œâ”€â”€â”€dtos
        â”‚   â”‚           â”‚       ProductDto.class
        â”‚   â”‚           â”‚
        â”‚   â”‚           â”œâ”€â”€â”€model
        â”‚   â”‚           â”‚       Product.class
        â”‚   â”‚           â”‚
        â”‚   â”‚           â””â”€â”€â”€repository
        â”‚   â”‚                   ProductRepository.class
        â”‚   â”‚
        â”‚   â””â”€â”€â”€db
        â”‚       â””â”€â”€â”€migration
        â”‚               V1__create-table-product.sql
        â”‚
        â””â”€â”€â”€test-classes
            â””â”€â”€â”€com
                â””â”€â”€â”€pedro
                    â””â”€â”€â”€crud
                            CrudApplicationTests.class
```

## Camadas do Projeto

### Model (Entidade)

- Classe responsÃ¡vel por mapear os dados da aplicaÃ§Ã£o para o banco de dados.
```java
@Entity(name = "product")
@Table(name = "product")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;
    private String name;
    private BigDecimal price;
}
```
- Explicando as anotaÃ§Ãµes:
  - `@Entity`: Marca a classe como uma entidade JPA (tabela lÃ³gica no modelo de persistÃªncia).
  - `name="product"`: Nome usado em consultas JPQL (nÃ£o no banco).
  - `@Table(name="product")`: Nome da tabela no banco.
  - `@Id`: Define o atributo id como chave primÃ¡ria.
  - `@GeneratedValue(strategy = GenerationType.AUTO)`: O valor do id serÃ¡ gerado automaticamente pelo provedor JPA.
  - UUID: Tipo usado para gerar identificadores Ãºnicos universais.

### DTO (Data Transfer Object)

- Camada intermediÃ¡ria usada para transferir dados sem expor diretamente a entidade.
```java
public record ProductDto(String name, BigDecimal price) {}
```

### Repository

- Interface que fornece mÃ©todos prontos para manipulaÃ§Ã£o do banco via Spring Data JPA.
```java
public interface ProductRepository extends JpaRepository<Product, UUID> {}
```

- JpaRepository<Product, UUID>: Gera mÃ©todos CRUD automaticamente (findAll, save, deleteById, etc.).
- NÃ£o Ã© necessÃ¡rio implementar nada manualmente para operaÃ§Ãµes bÃ¡sicas.

### Controller

- O ProductController Ã© a camada responsÃ¡vel por expor a API REST para gerenciar produtos no sistema, recebendo requisiÃ§Ãµes HTTP, processando-as e retornando respostas adequadas. Ele utiliza o ProductRepository para interagir com o banco de dados.
- Todos os endpoints estÃ£o mapeados sob a rota base /products.
- O controller interage diretamente com o ProductRepository para acessar e manipular os dados, e utiliza ProductDto como objeto de transferÃªncia para criaÃ§Ã£o e atualizaÃ§Ã£o.

```java
@RestController
@RequestMapping("/products")
public class ProductController {
    
    @Autowired
    ProductRepository repository; 

    @GetMapping
    public ResponseEntity getAll(){
        List<Product> listProducts = repository.findAll();
        return ResponseEntity.status(HttpStatus.OK).body(listProducts);
    }

    @GetMapping("/{id}")
    public ResponseEntity getById(@PathVariable(value = "id") UUID id){
        Optional<Product> product = repository.findById(id);
        if(product.isEmpty()){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found!");
        }
        
        return ResponseEntity.status(HttpStatus.FOUND).body(product.get());
    }

    @PostMapping
    public ResponseEntity save(@RequestBody ProductDto dto){
        var product = new Product();
        BeanUtils.copyProperties(dto, product);
        return ResponseEntity.status(HttpStatus.CREATED).body(repository.save(product));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity delete(@PathVariable(value = "id") UUID id) {
        Optional<Product> product = repository.findById(id);
        if(product.isEmpty()){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found!");
        }
        String productName = product.get().getName();
        repository.delete(product.get());

        return ResponseEntity.status(HttpStatus.OK).body("Product: '" + productName + "' deleted successfully.");

    }

    @PutMapping("/{id}")
    public ResponseEntity update(@PathVariable(value = "id") UUID id, @RequestBody ProductDto dto) {
        Optional<Product> product = repository.findById(id);
        if(product.isEmpty()){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found!");
        }
        var productModel = product.get();
        BeanUtils.copyProperties(dto, productModel);

        return ResponseEntity.status(HttpStatus.OK).body(repository.save(productModel));
    }
    
}
```
- Explicando as anotaÃ§Ãµes:
  - `@RestController`: Define que a classe Ã© um controlador REST, retornando os dados diretamente no corpo da resposta (JSON por padrÃ£o).
  - `@RequestMapping("/products")`: Define o caminho base `/products` para todos os endpoints da classe.
  - `@Autowired`: Injeta automaticamente a instÃ¢ncia de uma dependÃªncia (no caso, `ProductRepository`).
  - `@GetMapping`: Mapeia requisiÃ§Ãµes HTTP GET para um mÃ©todo.
  - `@PostMapping`: Mapeia requisiÃ§Ãµes HTTP POST para um mÃ©todo.
  - `@PutMapping`: Mapeia requisiÃ§Ãµes HTTP PUT para um mÃ©todo.
  - `@DeleteMapping`: Mapeia requisiÃ§Ãµes HTTP DELETE para um mÃ©todo.
  - `@PathVariable`: Liga o valor de uma variÃ¡vel na URL a um parÃ¢metro do mÃ©todo.
  - `@RequestBody`: Faz o binding do corpo da requisiÃ§Ã£o (JSON) para um objeto Java.

## Endpoints do Controller
### 1. GET /products
- DescriÃ§Ã£o: Retorna a lista de todos os produtos cadastrados.
- Retorno:
  - `200 OK` + lista de produtos (JSON).

### 2. GET /products/{id}
- DescriÃ§Ã£o: Retorna um produto especÃ­fico pelo seu ID (UUID).
- ParÃ¢metro:
  - id (UUID) â€“ Identificador Ãºnico do produto.
- Retorno:
  - `302 FOUND` + dados do produto, se encontrado.
  - `404 NOT_FOUND` se nÃ£o existir.

### 3. POST /products

- DescriÃ§Ã£o: Cria um novo produto no banco de dados.
  - Corpo da requisiÃ§Ã£o:
  - Objeto JSON seguindo o formato de ProductDto.
  - Retorno:
    - `201 CREATED` + dados do produto criado.

### 4. DELETE /products/{id}
- DescriÃ§Ã£o: Remove um produto existente pelo ID.
- ParÃ¢metro:
  - id (UUID) â€“ Identificador Ãºnico do produto.
- Retorno:
  - `200 OK`+ mensagem de confirmaÃ§Ã£o.
  - `404 NOT_FOUND` se nÃ£o existir.

5. PUT /products/{id}
- DescriÃ§Ã£o: Atualiza os dados de um produto existente.
- ParÃ¢metro:
  - id (UUID) â€“ Identificador Ãºnico do produto.
- Corpo da requisiÃ§Ã£o:
  - Objeto JSON seguindo o formato de ProductDto.
- Retorno:
  - `200 OK` + dados do produto atualizado.
  - `404 NOT_FOUND` se nÃ£o existir.


# âœ… ConclusÃ£o

Este projeto demonstrou como construir uma API REST completa utilizando **Spring Boot**, com operaÃ§Ãµes de **CRUD** sobre produtos, integrando **PostgreSQL** como banco de dados e utilizando boas prÃ¡ticas como **DTOs**, **camadas de arquitetura** e **migrations com Flyway**.

Com este projeto vocÃª aprendeu a:  
- Estruturar uma aplicaÃ§Ã£o Spring Boot em camadas (Controller, Service, Repository, Model).  
- Criar endpoints REST completos para criar, ler, atualizar e deletar recursos.  
- Conectar a aplicaÃ§Ã£o a um banco de dados PostgreSQL.  
- Utilizar DTOs para transferir dados entre camadas sem expor entidades diretamente.  
- Aplicar migrations com Flyway para versionamento do banco de dados.  
- Gerar identificadores Ãºnicos com **UUID** para os registros.  

---

# âš¡ Como testar a aplicaÃ§Ã£o

1. Certifique-se de que o **PostgreSQL** estÃ¡ rodando e a configuraÃ§Ã£o no `application.properties` estÃ¡ correta.  
2. Execute a aplicaÃ§Ã£o via IDE ou `./mvnw spring-boot:run`.  
3. Utilize ferramentas como **Postman** ou **Insomnia** para fazer requisiÃ§Ãµes HTTP aos endpoints:  

| MÃ©todo | Endpoint | DescriÃ§Ã£o |
|--------|----------|-----------|
| GET    | /products | Retorna todos os produtos |
| GET    | /products/{id} | Retorna um produto especÃ­fico |
| POST   | /products | Cria um novo produto |
| PUT    | /products/{id} | Atualiza um produto existente |
| DELETE | /products/{id} | Deleta um produto existente |

---

# ğŸ“– ReferÃªncias

- [Spring Boot Documentation](https://spring.io/projects/spring-boot)  
- [Spring Data JPA](https://spring.io/projects/spring-data-jpa)  
- [Flyway Migration](https://flywaydb.org/documentation/)  
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)  

---

# ğŸŒŸ PrÃ³ximos passos / Melhorias

- Adicionar camada **Service** para separar lÃ³gica de negÃ³cios do Controller.  
- Implementar **validaÃ§Ãµes** (Bean Validation) para dados de entrada.  
- Criar **tratamento global de exceÃ§Ãµes** com `@ControllerAdvice`.  
- Adicionar **autenticaÃ§Ã£o e autorizaÃ§Ã£o** (Spring Security).  
- Criar **testes unitÃ¡rios e de integraÃ§Ã£o** para os endpoints.
